# project_clojure
 Выполнение проекта СМП НГУ на тему "Облачные вычисления"

# Техническая документация

## Обзор
Этот проект реализует распределённую вычислительную платформу для управления удалённым выполнением функций, балансировки нагрузки и передачи данных. Он поддерживает:

- Прозрачное выполнение операций на удалённых серверах.
- Маршалинг кода и данных.
- Балансировку нагрузки между серверами.
- Параллельное и распределённое выполнение операций `map`.
- Оптимизированную передачу данных.
- Поддержку транспорта Java-объектов и байт-кода Clojure.
- Асинхронное выполнение заданий с мониторингом прогресса.

## Структура проекта

### Модуль API
Модуль API предоставляет интерфейсы для взаимодействия с системой, включая:

1. **Инициализация сервера**: Запуск сервера с использованием `-main`.
2. **Регистрация функций**: Позволяет пользователям регистрировать удалённые функции для выполнения.
   ```clojure
   (defn register-function [name code])
   ```
3. **Вызов удалённых функций**: Интерфейсы для вызова зарегистрированных удалённых функций.
   ```clojure
   (defn call-remote-function [func args])
   ```
4. **Отправка кода на Clojure**: Позволяет выполнять произвольный код Clojure удалённо.
   ```clojure
   (defn submit-clojure-code [code])
   ```
5. **Отправка Java-объектов**: Поддерживает отправку Java-объектов.
   ```clojure
   (defn submit-java-object [java-object])
   ```
6. **Параллельный `map`**: Выполняет функцию параллельно на коллекции аргументов.
   ```clojure
   (defn example-submit-parallel-map [])
   ```

### Модуль клиента
Модуль клиента отвечает за взаимодействие с серверами и отправку заданий:

1. **Выбор сервера**: Читает доступные серверы из `servers.edn` и выбирает оптимальный сервер на основе нагрузки.
   ```clojure
   (defn choose-server [func])
   ```
2. **Отправка заданий**: Отправляет задания на выбранный сервер для выполнения.
   ```clojure
   (defn submit-job [func args clojure-code java-object])
   ```
3. **Регистрация функций**: Отправляет запрос на регистрацию функций на сервере.
   ```clojure
   (defn register-remote-function [name code])
   ```

### Модуль сервера
Модуль сервера выполняет следующие задачи:

1. **Выполнение заданий**: Обрабатывает входящие запросы на выполнение заданий, включая вызовы удалённых функций, выполнение кода и обработку объектов.
2. **Управление функциями**: Регистрирует и хранит удалённые функции для последующих вызовов.
3. **Управление состоянием**: Отслеживает статус заданий и их результаты.

### Модули тестирования
Проект включает модули тестирования для компонентов клиента и сервера:

- **Тесты клиента**: Проверяют выбор сервера, отправку заданий и регистрацию функций.
- **Тесты сервера**: Проверяют выполнение функций, обработку заданий и обновление состояния.

## Примеры использования

### Регистрация удалённой функции
```clojure
(defn example-register-subtract []
  (register-function "subtract" "(fn [a b] (- a b))"))
(example-register-subtract)
```

### Вызов удалённой функции
```clojure
(defn example-call-remote-function []
  (call-remote-function 'add [6 7]))
(example-call-remote-function)
```

### Отправка произвольного кода на Clojure
```clojure
(defn example-submit-clojure-code []
  (submit-clojure-code "(+ 10 2)"))
(example-submit-clojure-code)
```

### Отправка Java-объекта
```clojure
(defn example-submit-java-object []
  (submit-java-object {:name "Alice" :age 30}))
(example-submit-java-object)
```

### Выполнение параллельного `map`
```clojure
(defn example-submit-parallel-map []
  (let [func 'add
        args [1 2 3 4 5]]
    (parallel-map func args)))
(example-submit-parallel-map)
```

## Установка и настройка

1. Установите зависимости:
   ```bash
   lein deps
   ```
2. Запустите сервер:
   ```bash
   lein run -m my-project.server
   ```
3. Настройте файл `servers.edn` с доступными серверами:
   ```edn
   [{:id 1 :port 3000 :load 0}
    {:id 2 :port 3001 :load 0}]
   ```

## Будущие улучшения

1. Улучшенная обработка ошибок и логика повторов.
2. Динамическое обнаружение и настройка серверов.
3. Повышенная безопасность с использованием аутентификации и авторизации.
4. Расширенные возможности мониторинга и логирования.
5. Поддержка дополнительных форматов данных и языков программирования.

## Зависимости

- Clojure 1.11.1
- Ring (Core, Jetty Adapter, JSON)
- Cheshire
- HTTP-Kit
- Core.Async
- clj-http

# Теоретическое описание

## Введение в облачные вычисления

**Облачные вычисления** – это модель предоставления вычислительных ресурсов, таких как серверы, хранилища, базы данных, сети и программное обеспечение, через интернет с оплатой по мере использования. Основное преимущество облачных вычислений заключается в их гибкости, масштабируемости и снижении затрат на оборудование.

Проект реализует распределённую вычислительную платформу, которая позволяет управлять выполнением удалённых операций, автоматизировать распределение нагрузки между серверами и оптимизировать передачу данных.

---

## Основные концепции, используемые в проекте

### 1. Распределённые вычисления
Распределённые вычисления позволяют выполнять задачи на нескольких узлах (серверах) одновременно. Это повышает производительность системы и обеспечивает надёжность: в случае отказа одного узла система продолжает работать.

В проекте распределённые вычисления реализованы через удалённые вызовы функций, поддержку параллельного выполнения операций `map` и возможность исполнения произвольного кода.

### 2. Маршалинг данных и кода
**Маршалинг** – это процесс преобразования данных и объектов в формат, пригодный для передачи по сети или хранения. В проекте реализована передача:
- **Clojure-кода** в форме текста, который затем интерпретируется на сервере.
- **Java-объектов**, преобразованных в сериализованный формат.

### 3. Балансировка нагрузки
Балансировка нагрузки распределяет входящие задачи между несколькими серверами, чтобы избежать перегрузки одного из них. Проект выбирает серверы с наименьшей загрузкой на основе данных конфигурационного файла `servers.edn`.

### 4. Параллельное и распределённое выполнение `map`
Функция `map` в функциональном программировании применяется для обработки коллекций. В проекте её выполнение распределяется между несколькими серверами, учитывая многоядерность процессоров. Это позволяет эффективно обрабатывать большие объёмы данных.

### 5. Асинхронность
Асинхронный подход позволяет выполнять задачи без ожидания их завершения. Это ускоряет обработку, так как запросы на выполнение заданий отправляются и обрабатываются параллельно.

### 6. Мониторинг прогресса
Система отслеживает статус выполнения заданий, включая их успешное завершение или возникновение ошибок.

---

## Архитектура проекта

### 1. Клиент
Клиентская часть отвечает за:
- Выбор сервера для выполнения задач.
- Отправку заданий (кода, функций, данных) на сервер.
- Регистрацию функций для удалённого выполнения.

### 2. Сервер
Серверная часть выполняет следующие задачи:
- Обрабатывает поступающие задания, включая выполнение функций, интерпретацию кода и обработку объектов.
- Хранит зарегистрированные функции для повторного использования.
- Обеспечивает обратную связь с клиентом о статусе выполнения задач.

### 3. API
API представляет собой интерфейс, который предоставляет доступ к основным возможностям системы, включая:
- Регистрацию функций.
- Вызов удалённых функций.
- Отправку произвольного кода и объектов.
- Выполнение параллельных операций.

### 4. Конфигурация
Файл `servers.edn` содержит описание доступных серверов, включая их порты и текущую загрузку. Эта информация используется для выбора подходящего сервера.

---

## Основные компоненты проекта

### 1. Регистрация функций
Пользователи могут регистрировать функции для последующего вызова. Это позволяет выполнять произвольные операции без необходимости повторной отправки кода.

### 2. Удалённый вызов функций
Система поддерживает удалённое выполнение заранее зарегистрированных функций. Это делает вызовы функций прозрачными для клиента.

### 3. Выполнение произвольного кода
Проект предоставляет возможность отправлять и исполнять произвольный Clojure-код на удалённых серверах. Это полезно для динамического выполнения задач, не предусмотренных заранее.

### 4. Работа с Java-объектами
Java-объекты могут быть сериализованы и отправлены для выполнения на сервере. Это расширяет совместимость проекта с языками JVM.

### 5. Параллельный `map`
Функция `parallel-map` разделяет входные данные между доступными серверами, что обеспечивает более быструю обработку больших коллекций.

---

## Преимущества подхода

1. **Масштабируемость**:  
   Проект поддерживает добавление новых серверов без необходимости модификации клиентского кода.

2. **Эффективность**:  
   Балансировка нагрузки и параллельное выполнение задач увеличивают производительность системы.

3. **Гибкость**:  
   Возможность отправки произвольного кода делает систему универсальной.

4. **Прозрачность**:  
   Пользователи взаимодействуют с функциями так же, как если бы они выполнялись локально.

---

## Возможные области применения

1. **Научные вычисления**:  
   Обработка больших наборов данных, требующих параллельных операций.

2. **Машинное обучение**:  
   Обучение моделей на распределённых данных.

3. **Обработка данных**:  
   Преобразование и анализ больших объёмов информации.

4. **Веб-сервисы**:  
   Выполнение серверных задач в распределённых средах.

---

## Заключение

Данный проект предоставляет мощную платформу для организации распределённых вычислений. Его архитектура позволяет пользователям запускать задачи на удалённых серверах, использовать ресурсы эффективно и гибко адаптироваться под разные сценарии. Разработка объединяет ключевые концепции облачных вычислений, такие как балансировка нагрузки, асинхронность и распределённое выполнение задач, обеспечивая высокую производительность и удобство использования.



